multiple.default.implementations=Method {0} contains an *{1}* instruction referencing a method reference {2} which has multiple default implementations: {3} and {4}
illegal.class.access={0} {1} {2} is not available at {3}
abstract.class.instantiation=Method {0} has instantiation *new* instruction referencing an abstract class {1}
class.not.found={0} {1} references an unresolved class {2}
super.class.became.interface=Class {0} has a *super class* {1} which is actually an *interface*
invoke.class.method.on.interface=Method {0} has invocation *{1}* instruction referencing a *class* method {2}, but the method''s host {3} is an *interface*
super.interface.became.class={0} {1} has a *super interface* {2} which is actually a *class*
invoke.interface.method.on.class=Method {0} has invocation *{1}* instruction referencing an *interface* method {2}, but the method''s host {3} is a *class*
inherit.from.final.class={0} {1} inherits from a final class {2}
interface.instantiation=Method {0} has instantiation *new* instruction referencing an interface {1}
change.final.field=Method {0} has modifying instruction *{1}* referencing a final field {2}
field.not.found=Method {0} contains a *{1}* instruction referencing an unresolved field {2}
illegal.field.access=Method {0} contains a *{1}* instruction referencing a {2} field {3} that a class {4} doesn''t have access to
illegal.method.access=Method {0} contains an *{1}* instruction referencing a {2} method {3} that a class {4} doesn''t have access to
invoke.interface.on.private.method=Method {0} contains an *invokeinterface* instruction referencing a private method {1}
method.not.found=Method {0} contains an *{1}* instruction referencing an unresolved method {2}
method.not.implemented=Non-abstract class {0} inherits from {1} but doesn''t implement the abstract method {2}
abstract.method.invocation=Method {0} contains an *{1}* instruction referencing a method {2} which doesn''t have a non-abstract implementation
overriding.final.method=Class {0} overrides the final method {1}
non.static.access.to.static.field=Method {0} has non-static access instruction *{1}* referencing a static field {2}
invoke.static.on.non.static.method=Method {0} contains an *invokestatic* instruction referencing a non-static method {1}
invoke.non.static.instruction.on.static.method=Method {0} contains an *{1}* instruction referencing a static method {2}
static.access.to.non.static.field=Method {0} has static access instruction *{1}* referencing a non-static field {2}
invalid.class.file=Class-file {0} referenced from {1} is invalid: {2}